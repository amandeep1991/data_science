# Things to be covered:
>1. About Interpreted Languages, Advantages/Disadvantages of Python, pydoc.
>2. Starting Python, Interpreter PATH, Using the Interpreter
>3. Running a Python Script, Python Scripts on UNIX/Windows, Python Editors and IDEs.
>4. Using Variables, Keywords, Built-in Functions, Strings, Different Literals, Math Operators and Expressions, Writing to the Screen, String Formatting, Command Line Parameters and Flow Control.

## 1.1 About Interpreted Languages
>1. Interpreter Languages:
>>* An interpreted language is a type of programming language for which most of its implementations execute instructions directly and freely, without previously compiling a program into machine-language instructions. 
>>* The interpreter executes the program directly, translating each statement into a sequence of one or more subroutines, and then into another language (often machine code).
>2. Compiler vs Interpreter:
>>* Compiler and Interpreter are two different ways to execute a program written in a programming or scripting language. 
>>* In general, interpreted programs run slower than the compiled programs.
>>> 1. **Compiler**:
>>>>* A compiler takes entire program and converts it into object code which is typically stored in a file. The object code is also refereed as binary code and can be directly executed by the machine after linking. Examples of compiled programming languages are C and C++. 
>>>>* Once a program is compiled, its source code is not useful for running the code. 
>>> 2. **Interpreter**:
>>>>* An Interpreter directly executes instructions written in a programming or scripting language without previously converting them to an object code or machine code. Examples of interpreted languages are Perl, Python and Matlab.
>>>>* For interpreted programs, the source code is needed to run the program every time.
>3. Python is an interpretor language:
>>* Python as a programming language has no saying about if it's an compiled or interpreted programming language, only the implementation of it. 
>>* The terms interpreted or compiled is not a property of the language but a property of the implementation. 
>>* Python program runs directly from the source code . so, Python will fall under byte code interpreted. 
>>>* The .py source code is first compiled to byte code as .pyc. This byte code can be interpreted (official CPython), or JIT compiled (PyPy). 
>>>* Python source code (.py) can be compiled to different byte code also like IronPython (.Net) or Jython (JVM). 
>>>* There are multiple implementations of Python language . The official one is a byte code interpreted one. 
>>>* There are byte code JIT compiled implementations too.
>>* As concluding remarks, Python(Cpython) is neither a true compiled time nor pure interpreted language but it is called interpreted language.
```

```python
print('Hello World')
```

## 1.2. Advantages/Disadvantages of Python,
>1. Advantages of Python:
>>1. **Extensive Support Libraries**: string operations, Internet, web service tools, operating system interfaces and protocols.
>>2. **Integration Feature**: can be called directly from excel, C, C++, Java etc.
>>3. **Improved Programmer’s Productivity**: clean OOPs design
>>4. **Specialized modules for specific problems**:
>>5. And many more....

>2. Disadvantages of Python:
>>1. **Difficulty in Using Other Languages**: 
>>>* The Python lovers become so accustomed to its features and its extensive libraries, so they face problem in learning or working on other programming languages.
>>2. **Weak in Mobile Computing**: 
>>>* Python has made its presence on many desktop and server platforms, but it is seen as a weak language for mobile computing. 
>>3. **Gets Slow in Speed**:
>>>* Python executes with the help of an interpreter instead of the compiler, which causes it to slow down
>>4. **Run-time Errors**:
>>>* dynamically typed so it has many design restrictions that are reported by some Python developers.
>>5. **Underdeveloped Database Access Layers**: 
>>>*. As compared to the popular technologies like JDBC and ODBC, the Python’s database access layer is found to be bit underdeveloped and primitive. 


## 1.3 pydoc vs help: 
>* The pydoc module automatically generates documentation from Python modules.
>>* Sample Commands:
>>>```terminal
pydoc math
pydoc HelloWorld
    ```

>* help is a python shell built-in support to see documentation:
```python
help()      # Starts an interactive help (hit q+ enter to escape)
help("topics")  # Outputs the list of help topics
help("OPERATORS") # Shows help on the topic of operators
help("len")    # Shows help on len function
help("re")    # Shows help on re module
help("re.sub")  # Shows help on sub function from re module
help(len)     # Shows help on the object passed, the len function
help([].pop)   # Shows help on the pop function of a list
dir([])      # Outputs a list of attributes of a list, which includes functions
import re
help(re)     # Shows help on the help module
help(re.sub)   # Shows help on the sub function of re module
help(1)      # Shows help on int type
help([])     # Shows help on list type
help(def)     # Fails: def is a keyword that does not refer to an object
help("def")    # Shows help on function definitions
```

## 2.1. Starting Python

>* Starting Interpreter
>>* Running scripts (from terminal/command prompt):
>>> python <script_name>.py
>>* Open Python Console (from terminal/command prompt):
>>> python


## 2.2. Interpreter PATH
>* Finding  path of interpreter:
>>>
```python
import sys
sys.executable
```

## 2.3. Using the Interpreter (python shell)
>
```python
print(5 + 5)
print(5 - 5)

company_name = "Royal Bank of Scotland"
employee_name = "Amandeep"

employee_skills = ['Data Science', 'Python', 'Java']

print(company_name)
print(employee_skills)
```

## 3.1 Running a Python Script (Windows)
>>* Running scripts (from command prompt):
>>> python script_name.py

## 3.2 Python Scripts on LINUX/UNIX
>>* Running scripts (from terminal):
>>>* python2 script_name.py
>>>* python3 script_name.py

## 3.3 Python Editors and IDEs.
>* General Editors and IDEs with Python Support
>>* Eclipse + PyDev
>>* Sublime Text
>>* Atom
>>* GNU Emacs
>>* Vi / Vim
>>* Visual Studio
>>* Visual Studio Code
>* Python-Specific Editors and IDEs
>>* PyCharm
>>* Spyder
>>* Thonny

## 4.1. Using Variables:
>* Unlike other programming languages, Python has no command for declaring a variable.
>* A variable is created the moment you first assign a value to it.

>>>>
```python
x = 7
y = "Amandeep"
print(x)
print(y)
```

>* Variables do not need to be declared with any particular type and can even change type after they have been set.

>>>>
```python
x = 1 # x is of type int
print(x)
print(type(x))
x = "Amandeep" my_line
print(x)
print(type(x))
```

>* Remember that variables are case-sensitive
>* A variable name must start with a letter or the underscore character
>* A variable name cannot start with a number
>* A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ )
>* Variable names are case-sensitive (age, Age and AGE are three different variables)

## 4.2. Keywords:
>* Keywords are the reserved words in Python.  We cannot use a keyword as variable name, function name or any other identifier.

>* Few keywords:
```css
and       del       from      not       while
as        elif      global    or        with
assert    else      if        pass      yield
break     except    import    print
class     exec      in        raise
continue  finally   is        return 
def       for       lambda    try
```

>* keywords can be identified using python code:
>>>
```python
import keyword
print(keyword.kwlist)
```

>* One Liner Explaination of keywords
print
print to console

>>* while
>>> controlling the flow of the program

>>* for
>>> iterate over items of a collection in order that they appear

>>* break
>>> interrupt the (loop) cycle, if needed

>>* continue
>>> used to interrupt the current cycle, without jumping out of the whole cycle. 
>>> New cycle will begin.

>>* if
>>> used to determine, which statements are going to be executed.

>>* elif
>>> stands for else if.If the first test evaluates to False,
>>> then it continues with the next one

>>* else
>>> is optional. The statement after the else keyword is executed, 
>>> unless the condition is True

>>* is
>>> tests for object identity

>>* not
>>> negates a boolean value

>>* and
>>> all conditions in a boolean expression must be met

>>* or
>>> at least one condition must be met.

>>* import
>>> import other modules into a Python script

>>* as
>>> if we want to give a module a different alias

>>* from
>>> for importing a specific variable, class or a function from a module

>>* def
>>> used to create a new user defined function

>>* return
>>> exits the function and returns a value

>>* lambda
>>> creates a new anonymous function

>>* global
>>> access variables defined outside functions

>>* try
>>> specifies exception handlers 

>>* except
>>> catches the exception and executes codes

>>* finally
>>> is always executed in the end. Used to clean up resources.

>>* raise
>>> create a user defined exception

>>* del
>>> deletes objects

>>* pass
>>> does nothing

>>* assert
>>> used for debugging purposes

>>* class
>>> used to create new user defined objects

>>* exec
>>> executes Python code dynamically

>>* yield
>>> is used with generators

>* **None Keyword**:
```python
None == 0 - False
None == [] - False
None == False - False
x = None
y = None
x == y - True
```



## 4.3. Built-in Functions:
***
> **abs()**: Returns the absolute value of a number

```python
abs(-1)
```

***
> **all()**: Returns True if all items in an iterable object are true

```python
mylist = [0, 1, 1]
print(all(mylist))

#Hint: 1 is true
mytuple = (0, True, True)
print(all(mytuple))

#Hint: keys
mydict = {0 : "Apple", 1 : "Orange"}
print(all(mydict))
```

***
> **any()**: Returns True if any item in an iterable object is true

```python
mylist = [0, 1, 1]
print(any(mylist))

#Hint: 1 is true
mytuple = (0, True, True)
print(any(mytuple))

#Hint: keys
mydict = {0 : "Apple", 1 : "Orange"}
print(any(mydict))
```

***
> **ascii()**: Returns a readable version of an object. Replaces non-ascii characters with escape character

```python
print(ascii("My name is Ståle"))
print(ascii("¥"))
```

***
> **bin()**: Returns the binary version of a number [bin(integer)]

```python
print(bin(7))

#Hint: read above description carefully
print(bin(-1.1))

print(bin(8))

print(bin(9999999))

print(type(bin(8)))
```

***
> **bool()**: Returns the boolean value of the specified object [bool(object)]
>> The object will always return True, unless:
>>>1. The object is empty, like [], (), {}, set()
>>>2. The object is False
>>>3. The object is 0
>>>4. The object is None

```python
print(bool([1,2]))
print(bool([]))
print(bool((1,2)))
print(bool(()))
print(bool({1:2,11:22}))
print(bool({}))
print(bool(True))
print(bool(False))
print(bool(1))
print(bool(0))
print(bool('None'))
print(bool(None))
```

***
> **bytearray()**: Returns an array of bytes
>>* It can convert objects into bytearray objects, or create empty bytearray object of the specified size.
>>* The bytearray type is a mutable sequence of integers in the range 0 <= x < 256. It can be used to work with low-level binary data such as that inside of images or arriving directly from the network.
>>* First thing to understand is that computers work using electrical signals (well nearly all of the current stuff do). I.e. they work in the same way a light and switch works - when the power flows the light turns on, if not it's off. That is the exact same thing happening in a computer at a very low level. It's just many thousands to billions of these switches inside the computer turning on/off different elements inside it.
>>>* bytearray(x, encoding_of_output, error_handler)

```python
x = bytearray(4)
print(x)
print(type(x))

print(bytearray())

# print(bytearray(u'źdźbło', 'ascii', 'strict'))
print(bytearray(u'źdźbło', 'ascii', 'ignore'))
print(bytearray(u'źdźbło', 'ascii', 'xmlcharrefreplace'))
print(bytearray(u'źdźbło', 'ascii', 'backslashreplace'))

#Hint: strict will throw error only in case of any issue
print(bytearray('abcd', 'ascii', 'strict'))
print(bytearray(u'abcd', 'ascii', 'backslashreplace'))
```

***
> **bytes()**: Returns a bytes object
>>* It can convert objects into bytes objects, or create empty bytes object of the specified size.
>>* **The difference between bytes() and bytearray() is that bytes() returns an object that cannot be modified, and bytearray() returns an object that can be modified.** 
>>>* bytes(x, encoding, error_handler)

```python
print(bytes(4)) #Return an array of 4 bytes
```

***
> **callable()**: Returns True if the specified object is callable, otherwise False

```python
a=10
def x(input):
  if input> 5:
    return False
  return True

print(callable(x))
print(callable(a))

print(list(filter(x, [9,3,7,8,2,1])))
```

***
> **chr()**: Returns a character from the specified Unicode code.

```python
print(chr(97)) #Get the character that represents the unicode 97
```

***
> **classmethod()**: Converts a method into a class method
>>* A class method is a method that is bound to a class rather than its object. It doesn't require creation of a class instance, much like staticmethod.
>>* The difference between a static method and a class method is:
>>>* Static method knows nothing about the class and just deals with the parameters
>>>* Class method works with the class since its parameter is always the class itself.
>>>>* Class().classmethod() 
>>>>* Class.classmethod()
>>>* in newer Python versions, you can use the @classmethod decorator for classmethod definition. {**FACTORY METHOD DESIGN PATTERN**}

```python
#Example #1
class Person:
    age = 25

    def printAge(cls): #cls if actually denoting self here (we can use name as per our choice)
        print('The age is:', cls.age)

p = Person()
p.age = 30
p.printAge()

# create printAge class method
Person.printAge = classmethod(Person.printAge)
Person.printAge()

p = Person()
p.age = 30
p.printAge()

# Person.printAge = classmethod(Person.printAge)
# Person.printAge()


#Example #2: Create factory method using class method
from datetime import date

# random Person
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def fromBirthYear(cls, name, birthYear):
        return cls(name, date.today().year - birthYear)

    def display(self):
        print(self.name + "'s age is: " + str(self.age))

person = Person('Adam', 19)
person.display()

person1 = Person.fromBirthYear('Aman',  1985)
person1.display()
```

***
> **compile()**: Returns the specified source as an object, ready to be executed [**compile(source, filename, mode, flag, dont_inherit, optimize)**]
>>* **source**:	Required. The source to compile, can be a String, a Bytes object, or an AST object
>>* **filename**:	Required. The name of the file that the source comes from. **If the source does not come from a file, you can write whatever you like**
>>* **mode**:	Required. Legal values:
>>>* **eval**: - if the source is a single expression
>>>* **exec**: - if the source is a block of statements
>>>* **single**: - if the source is a single interactive statement
>>* flags:	Optional. How to compile the source. Default 0
>>* dont-inherit:	Optional. How to compile the source. Default False
>>* optimize:	Optional. Defines the optimization level of the compiler. Default -1


```python
codeInString = 'print("India is Awesome")'
codeObejct = compile(codeInString, 'motherland', 'exec')
exec(codeObejct)
```

***
> **complex()**: Returns a complex number or converts a string into complex number [complex(real, imaginary), complex('3+5j')]

```python
print(complex(3, 5))
```

***
> **delattr()** or **del operator**: Deletes the specified attribute (property or method) from the specified object

```python
class Student:
  name = "Sahil"
  age = 28
  country = "India"
  
  #def __init__(self, name='Rajat', age=10, country='Ireland'):
  #  self.name=name
  #  self.age=age
  #  self.country=country

my_object = Student()

del Student.age 
delattr(Student, 'country') 

print(my_object.name)
#print(my_object.age) # Failing because age attribute has been deleted now
#print(my_object.country)

my_student = Student()
# print(my_student.age) # this has been deleted from the class itself

#Following would be helpful to validate the changes
dir(Student)
help(Student)
```

***
> **dict()**: Returns a dictionary (Array)

```python
print(dict(name = "Sahil", age = 26, country = "India"))
```

***
> **dir()**: This function will return all the properties and methods, even built-in properties which are default for all object, without the values.

```python
class Student:
  name = "Sahil"
  age = 28
  country = "India"
  
print(dir(Student))
```

***
> **divmod()**: Returns the quotient and the remainder when argument1 is divided by argument2

```python
divide_results_tuple = divmod(5, 2)
quotient, remainder = divmod(5, 2)
```

***
> **enumerate()**: Takes a collection (e.g. a tuple) and returns it as an enumerate object
>>* The enumerate() function adds a counter as the key of the enumerate object.

```python
x = ('apple', 'banana', 'cherry')
enumerate_object = enumerate(x)
for enumerate_object_tuple in enumerate_object:
    print(enumerate_object_tuple)
```

***
> **eval()**: Evaluates and executes an expression [eval(expression[, globals, locals])]
>>* **BE CAREFUL**: If you allow users to input a value using eval(input()), the user may issue commands to change file or even delete all the files using command os.system('rm -rf *')
>>* If both parameters are omitted (global & locals), the expression is executed in the current scope. You can check the available variables and methods using code

```python
x = 'print("Aman is a good boy")'
print(eval(x))

x = '4**2'
print(eval(x))

print(eval('locals()', {'Sahil': 'Python'}, {'Amandeep': 'Data Science'}))
#print(eval('globals()', {'Sahil': 'Python'}, {'Amandeep': 'Data Science'}))
```

***
> **exec()**: Executes the specified code (or object) exec(object, globals, locals])

```python
#print(eval('x=3')) #Error because it is a statement not an expression; (variable_name = expression) is a statement

print(exec('x=3')) #Will run this statement
```

***
> **filter()**: Use a filter function to exclude items in an iterable object. [filter(function, iterable)]

```python
ages = [5, 12, 17, 18, 24, 32]

def myFunc(x):
  if x < 18:
    return False
  else:
    return True

adults = filter(myFunc, ages)

for x in adults:
  print(x)
```

***
> **float()**: Returns a floating point number

```python
print(float("3.500"))
print(float(3))
print(float("3.501"))
```

***
> **format()**: Formats a specified value. [format(value, format)]
>>* value:	A value of any format
>>* format:	The format you want to format the value into. Possible Values::
>>> 1. **'<'** - Left aligns the result (within the available space)
>>> 2. **'>'** - Right aligns the result (within the available space)
>>> 3. **'^'** - Center aligns the result (within the available space)
>>> 4. **'='** - Places the sign to the left most position
>>> 5. **'+'** - Use a sign to indicate if the result is positive or negative
>>> 6. **'-'** - Use a sign for negative values only
>>> 7. **' '** - Use a leading space for positive numbers
>>> 8. **','** - Use a comma as a thousand separator
>>> 9. **'_'** - Use a underscore as a thousand separator
>>>10. **'b'** - Binary format
>>>11. **'c'** - Converts the value into the corresponding unicode character
>>>12. **'d'** - Decimal format
>>>13. **'e'** - Scientific format, with a lower case e
>>>14. **'E'** - Scientific format, with an upper case E
>>>15. **'f'** - Fix point number format
>>>16. **'F'** - Fix point number format, upper case
>>>17. **'g'** - General format
>>>18. **'G'** - General format (using a upper case E for scientific notations)
>>>19. **'o'** - Octal format
>>>20. **'x'** - Hex format, lower case
>>>21. **'X'** - Hex format, upper case
>>>22. **'n'** - Number format
>>>23. **'%'** - Percentage format

```python
def check_format_method(variable_value):
    print('<', ' ==> ', format(variable_value, '<'))
    print('>', ' ==> ', format(variable_value, '>'))
    print('^', ' ==> ', format(variable_value, '^'))
    print('=', ' ==> ', format(variable_value, '='))
    print('+', ' ==> ', format(variable_value, '+'))
    print('-', ' ==> ', format(variable_value, '-'))
    print(' ', ' ==> ', format(variable_value, ' '))
    print(',', ' ==> ', format(variable_value, ','))
    print('_', ' ==> ', format(variable_value, '_'))
    print('b', ' ==> ', format(variable_value, 'b'))
    #print('c', ' ==> ', format(variable_value, 'c'))
    print('d', ' ==> ', format(variable_value, 'd'))
    print('e', ' ==> ', format(variable_value, 'e'))
    print('E', ' ==> ', format(variable_value, 'E'))
    print('f', ' ==> ', format(variable_value, 'f'))
    print('F', ' ==> ', format(variable_value, 'F'))
    print('g', ' ==> ', format(variable_value, 'g'))
    print('G', ' ==> ', format(variable_value, 'G'))
    print('o', ' ==> ', format(variable_value, 'o'))
    print('x', ' ==> ', format(variable_value, 'x'))
    print('X', ' ==> ', format(variable_value, 'X'))
    print('n', ' ==> ', format(variable_value, 'n'))
    print('%', ' ==> ', format(variable_value, '%'))
    
check_format_method(100)
check_format_method(255)

#check_format_method(100/100) #Error, no binary for float numbers

check_format_method(100//100) #Error, no binary for float numbers

check_format_method(2000000)
```

***
> **frozenset()**: Returns an unchangeable frozenset object (which is like a set object, only **unchangeable**) [frozenset(iterable)]

```python
mylist = ['apple', 'banana', 'cherry']
x = frozenset(mylist)

# x[1] = "strawberry" # will throw error
```

***
> **getattr()**: Returns the value of the specified attribute (property or method) [getattr(object, attribute, default)]

```python 
class Student:
  name = "Sahil"
  age = 28
  country = "India"
  
print(getattr(Student, 'age'))
print(Student.age)


print(getattr(Student, 'salary', format(1250000,',')))
```

***
> **globals()**: Returns the current global symbol table as a dictionary

```python
print(globals())
```

***
> **hasattr()**: Returns True if the specified object has the specified attribute (property/method)

```python
print(hasattr(Student, 'salary'))
```

***
> **hash()**: Returns the hash value of a specified object
>>* Hash values are just integers which are used to compare dictionary keys during a dictionary lookup quickly.
>>* Internally, hash() method calls __hash__() method of an object which are set by default for any object.
>>* For correct hash implementation, __hash__() should always return an integer. And, both __eq__() and __hash__() methods have to be implemented.
>>* Cases for custom hash implementation for objects

|__eq__()|__hash__()|Description|
| ------ |:--------:| ---------:|
|Defined (by default)|Defined (by default)|If left as is, all objects compare unequal (except themselves)|
|(If mutable) Defined|Should not be defined|Implementation of hashable collection requires key's hash value be immutable|
|Not defined|Should not be defined|If __eq__() isn't defined, __hash__() should not be defined.|
|Defined|Not defined|Class instances will not be usable as hashable collection.<BR> __hash__() implicity set to None. <BR> Raises TypeError exception if tried to retrieve the hash.|
|Defined|Retain from Parent|__hash__ = 'ParentClass'.__hash__|
|Defined|Doesn't want to hash|__hash__ = None. <BR> Raises TypeError exception if tried to retrieve the hash|

```python
# hash for integer unchanged
print('Hash for 786 is:', hash(786))

# hash for decimal
print('Hash for 786.13 is:',hash(786.13))

# hash for string
print('Hash for Amandeep is:', hash('Amandeep'))
```

***
> **help()**: Executes the built-in help system

```python
help('list')
```

***
> **hex()**: Converts a number into a hexadecimal value [hex(number/integer)]
>>* The returned string always starts with the prefix 0x 

```python
print(hex(255))
print(hex(10))
```

***
> **id()**: Returns the id of an object [id(object)]
>>* The id() function returns a unique id for the specified object.
>>* All objects in Python has its own unique id.
>>* The id is assigned to the object when it is created.
>>* The id is the object's memory address, and will be different for each time you run the program. (except for some object that has a constant unique id, like integers from -5 to 256)

```python
print(id('Amandeep'))
print(id("Amandeep"))

x1 = id('Amandeep')
x2 = id('Amandeep')

print(x1 == x2) #True because string is immutable

s1 = Student()
s2 = Student()
print(id(s1) == id(s2))
```

***
> **input()**: Allowing user input

```python
print('Enter your name:')
x = input()
print('Hello, ' + x)
```

***
> **int()**: Returns an integer number [int(value, base)]
>>*  **base**: A number representing the number format. Default value: 10

```python
print(int(100))
print(int('100', 2)) #Prints 4
```

***
> **isinstance()**: Returns True if a specified object is an instance of a specified object [isinstance(object, **type_or_tuple**)]

```python
print(isinstance(5, int))
print(isinstance("Amandeep", (float, int, str, list, dict, tuple)))
```

***
> **issubclass()**: Returns True if a specified class is a subclass of a specified object [issubclass(object, **subclass_or_tuples_of_subclasses**)]

```python
#Example 1
class MyAge:
  age = 36
    

class MyReligion:
  age = 36

class Student(MyAge):
  name = "Sahil"
  age = MyAge

print(issubclass(Student, MyAge))
    
class Indian(MyReligion, MyAge):
    name='Sahil'
    age=MyAge
    religion = MyReligion

print(issubclass(Indian, MyAge))
print(issubclass(Indian, MyReligion))

#(Indian()).age.age


#Example 2
class Polygon:
  def __init__(polygonType):
    print('Polygon is a ', polygonType)

class Triangle(Polygon):
  def __init__(self):
    Polygon.__init__('triangle')
    
print(issubclass(Triangle, Polygon))
print(issubclass(Triangle, list))
print(issubclass(Triangle, (list, Polygon)))
print(issubclass(Polygon, (list, Polygon)))

```

***
> **iter()**: Returns an iterator object [iter(object, subclass)]
>>* **object**: Required. An iterable object
>>* **sentinel**: Optional. If the object is a **callable object** the iteration will stop when the returned value is the same as the sentinel

```python
#Example #1
x = iter(["apple", "banana", "cherry"])
print(next(x))
print(next(x))
print(next(x))

#Example #2
my_list = list('abcdefghijkl')
counter = 0
def stop():
    global ch, counter
    ch = my_list[counter]
    counter+=1
    return ch

x = iter(stop, "g")
print(next(x))
print(next(x))
print(next(x))
print(next(x))
print(next(x))
print(next(x))
next(x) # Throws error

```

***
> **len()**: Returns the length of an object

```python
mylist = ["Amandeep", "Sahil", "Rajat"]
print(len(mylist))

print(len('Amandeep'))
```

***
> **list()**: Returns a list: list(iterable)

```python
print(list(("Amandeep", "Sahil", "Rajat")))
print(list('Amandeep'))
```

***
> **locals()**: Returns an updated dictionary of the current local symbol table

```python
print(locals())
```

***
> **map()**: Returns the specified **iterator** with the specified function applied to each item [map(function, **iterables**)]

```python
def myfunc(n):
  return len(n)

my_mapper = map(myfunc, ("Amandeep", "Sahil", "Rajat"))

for l in my_mapper:
    print(l)

#Hint: Iterator reached to end
print(list(my_mapper))    # will print empty list but below wouldn't print empty

print(list(map(myfunc, ("Amandeep", "Sahil", "Rajat"))))  


def myfunc2(w1,w2):
  return w1[:-1] + '-' + w2[:-1]
   
print(list(map(myfunc2, ("Amandeep1", "Sahil1", "Rajat1"), ("Amandeep2", "Sahil2", "Rajat2"))))    
```

***
> **max()**: Returns the largest item in an iterable [max(n1, n2, n3, ...) or max(iterable]

```python
print(max(1,2,3,5))

print(max([1,2,8,5]))

#Hint: alphatically highest
print(max("Amandeep", "Sahil", "Rajat"))
```

***
> **memoryview()**: Returns a memory view object [More details are here>>](https://www.programiz.com/python-programming/methods/built-in/memoryview)
>>* Advantage: memoryview objects allow Python code to access the internal data of an object that supports the buffer protocol without copying.
    
```python
x = memoryview(b"Hello")

print(x)

#return the Unicode of the first character
print(x[0])

#return the Unicode of the second character
print(x[1])
    
#Example:
v = memoryview(b'abcefg')

v[1]
#98

v[-1]
#103

chr(103)
#'g'

v[1:4]
#<memory at 0x7f3ddc9f4350>

bytes(v[1:4])
#b'bce'
```

***
> **min()**: Returns the smallest item in an iterable [min(n1, n2, n3, ...) or min(iterable]

```python
print(min(1,2,3,5))

print(min([1,2,8,5]))

#Hint: alphatically highest
print(min("Amandeep", "Sahil", "Rajat"))
```

***
> **next()**: Returns the next item in an iterable [next(iterable, default)]

```python
#Example #2
my_list = list('abcdefghijkl')
counter = 0
def stop():
    global ch, counter
    ch = my_list[counter]
    counter+=1
    return ch

x = iter(stop, "g")
print(next(x))
print(next(x))
print(next(x))
print(next(x))
print(next(x))
print(next(x))
print(next(x, 'Amandeep')) # Without default value it will throw the error [StopIteration]
```

***
> **object()**: Returns a new object
>>* The object() function returns an empty object.
>>* You cannot add new properties or methods to this object.
>>* This object is the base for all classes, it holds the built-in properties and methods which are default for all classes.

```python
print(object())
print(type(object()))
```

***
> **oct()**: Converts a number into an octal

```python
print(oct(10))
print(oct(12))
print(oct(8))
```

***
> **open()**: Opens a file and returns a file object [open(file, mode)]
>>* file: The path and name of the file
>>* mode: 

>>>* A string, define which mode you want to open the file in:
>>>>* "r" - Read - Default value. Opens a file for reading, error if the file does not exist
>>>>* "a" - Append - Opens a file for appending, creates the file if it does not exist
>>>>* "w" - Write - Opens a file for writing, creates the file if it does not exist
>>>>* "x" - Create - Creates the specified file, returns an error if the file exist

>>>* In addition you can specify if the file should be handled as binary or text mode
>>>>* "t" - Text - Default value. Text mode 
>>>>* "b" - Binary - Binary mode (e.g. images) 

```python
f = open("demofile.txt", "r")
print(f.read())
```

***
> **ord()**: Convert an integer representing the Unicode of the specified character [ord(**character**)]

```python
print(ord('a'))
print(ord('ab')) #Throws error because only 1 character is expected
```

***
> **pow()**: Returns the value of x to the power of y [pow(base, exponent[, modulus])]

```python
print(pow(4, 3))
print(pow(4, 3, 5)) # May not work in pycharm console as it import few basic modules like 'from math import *'
```

***
> **print()**: Prints to the standard output device [print(object(s), separator=separator, end=end, file=file, flush=flush)]


|Parameter          |Description|
| ------            |:--------: |
|object(s)          |Any object, and as many as you like. Will be converted to string before printed|
|sep='separator'    |Optional. Specify how to separate the objects, if there is more than one. Default is ''|
|end='end'          |Optional. Specify what to print at the end. Default is '\n' (line feed)|
|file               |Optional. An object with a write method. Default is sys.stdout|
|flush              |Optional. A Boolean, specifying if the output is flushed (True) or buffered (False). Default is False|


```python
print('India is Awesome')
```

***
> **property()**: Gets, sets, deletes a property [property(fget=None, fset=None, fdel=None, doc=None)]
>>>

```python
#Example #1
class Celsius:
    def __init__(self, temperature = 0):
        self.temperature = temperature

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

    def get_temperature(self):
        print("Getting value")
        return self._temperature

    def set_temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        print("Setting value")
        self._temperature = value

    temperature = property(get_temperature,set_temperature) # did mapping
    
c = Celsius()
c.temperature
c.temperature = 37
c.to_fahrenheit()


#Example #2
class Celsius:
    def __init__(self, temperature = 0):
        self._temperature = temperature

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

    @property
    def temperature(self):
        print("Getting value")
        return self._temperature

    @temperature.setter
    def temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        print("Setting value")
        self._temperature = value

    
c = Celsius()
c.temperature
c.temperature = 37
c.to_fahrenheit()
```

***
> **range()**: Returns a sequence of numbers, starting from 0 and increments by 1 (by default) [range(start, stop, step)]

```python
for n in range(3, 6):
  print(n)

for n in range(3, 20, 2):
  print(n)
```

***
> **repr()**: Returns a readable version of an object (like toString in Java)

```python
#Example #1
var = 'foo'
repr(var)

#Example #2
class Student:
    name = 'Sahil'
    age=28

    def __repr__(self):
        return self.name+ ' is ' +str(self.age) + ' years old!!'

repr(Student())
```

***
> **reversed()**: Returns a reversed iterator

```python
names = ["Amandeep", "Sahil", "Rajat"]
reversed_sequence_names = reversed(names)
for x in reversed_sequence_names:
  print(x)
```

***
> **round()**: Rounds a numbers [round(number, digits)]

```python
print(round(5.76543, 2))
```

***
> **set()**: Returns a new set object
>>* The items in a set list are unordered, so it will appear in random order.

```python
print(set(("Amandeep", "Sahil", "Rajat")))
```
> **setattr()**: Sets an attribute (property/method) of an object

```python
class Student:
  name = "Sahil"
  age = 28
  country = "India"

setattr(Student, 'age', 40)
```

***
> **slice()**: Returns a slice object [slice(start, end, step)]

```python
#Example #1
a = ("a", "b", "c", "d", "e", "f", "g", "h")
x = slice(3, 5)
print(a[x])

#Example #2
a = ("a", "b", "c", "d", "e", "f", "g", "h")
x = slice(0, 8, 3)
print(a[x])
```

***
> **sorted()**: Returns a sorted list [sorted(iterable, key=key, reverse=reverse)]
>>* **You cannot sort a list that contains BOTH string values AND numeric values** 

```python
#Example #1:
a = (1, 11, 2)
x = sorted(a)
print(x)


#Example #2:
a = ("a", "b", "c", "d", "e", "f", "g", "h")
x = sorted(a, reverse=True)
print(x)

names_list = ["Sahil", "Shiv Kumar", "Rajat", "Amandeep"]
print(sorted(names_list, key=len, reverse=True))

```
> **@staticmethod()**: 	Converts a method into a static method
>>* in newer versions of Python, you can use the Python decorator @staticmethod
>>* Static methods have very limited use case, because like class methods or any other methods within a class, they cannot access properties of the class itself.
>>* Static methods are used when we don't want subclasses of a class change/override a specific implementation of a method.


```python
#Example #1
class Dates:
    def __init__(self, date):
        self.date = date
        
    def getDate(self):
        return self.date

    @staticmethod
    def toDashDate(date):
        return date.replace("/", "-")

date = Dates("15-12-2016")
dateFromDB = "15/12/2016"
dateWithDash = Dates.toDashDate(dateFromDB)

if(date.getDate() == dateWithDash):
    print("Equal")
else:
    print("Unequal")
    
    


#Example #2
class Dates:
    def __init__(self, date):
        self.date = date
        
    def getDate(self):
        return self.date

    @staticmethod
    def toDashDate(date):
        return date.replace("/", "-")

class DatesWithSlashes(Dates):
    def getDate(self):
        return Dates.toDashDate(self.date)

date = Dates("15-12-2016")
dateFromDB = DatesWithSlashes("15/12/2016")

if(date.getDate() == dateFromDB.getDate()):
    print("Equal")
else:
    print("Unequal")
```

***
> **str()**: Returns a string object [str(object, encoding=encoding, errors=errors)]

|Parameter|	Description|
|---------|------------|
|object	  |  Any object. Specifies the object to convert into a string|
|encoding	|The encoding of the object. Default is UTF-8|
|errors	  |  Specifies what to do if the decoding fails|

```python
str(1)
```

***
> **sum()**: Sums the items of an iterator [sum(iterable, start)]

```python
a = (1, 2, 3, 4, 5)
print(sum(a))
print(sum(a, 7))
```

***
> **tuple()**: Returns a tuple [tuple(iterable)]
>>* **You cannot change or remove items in a tuple**

```python
print(tuple([1,2,3,4]))
print(tuple('India is Awesome'))
```

***
> **type()**: Returns the type of an object

```python
a = ('apple', 'banana', 'cherry')
b = "Hello World"
c = 33

print(type(a))
print(type(b))
print(type(c))
```

***
> **vars()**: Returns the __dict__ property of an object

```python
class Student:
  name = "Sahil"
  age = 28
  country = "India"

x = vars(Student)
print(x)
```

***
> **zip()**: Returns an iterator, from two or more iterators

```python
for i in zip([1,2,3,4],['Aman','Sahil','Rajat','Shiv']):
    print(i)
    print(type(i))
    
#Hint: Return x number of elements where x is min of all element sizes
for i in zip([1,2,3,4],['Aman'],'Sahil','Rajat','Shiv'):
    print(i)
    print(type(i))
    
#Hint: Every element needs to be iterable in zip    
for i in zip([1,2,3,4],['Aman'],'Sahil','Rajat','Shiv',1):
    print(i)
```

***
> str() vs repr()
>>* str() is used for creating output for end user while repr() is mainly used for debugging and development. repr’s goal is to be unambiguous and str’s is to be readable.

```python
s = 'Hello, Geeks.'
print(str(s))
print(str(2.0/11.0))

print(repr(s))
print(repr(2.0/11.0))
```

***
>* Class method vs Static Method
>>* A class method takes cls as first parameter while a static method needs no specific parameters.
>>* A class method can access or modify class state while a static method can’t access or modify it.
>>* In general, static methods know nothing about class state. They are utility type methods that take some parameters and work upon those parameters. On the other hand class methods must have class as parameter.
>>* We use @classmethod decorator in python to create a class method and we use @staticmethod decorator to create a static method in python.
>>* Usese:
>>>* We generally use class method to create factory methods. Factory methods return class object ( similar to a constructor ) for different use cases.
>>>* We generally use static methods to create utility functions.

```python
# Python program to demonstrate 
# use of class method and static method.
from datetime import date
 
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
     
    # a class method to create a Person object by birth year.
    @classmethod
    def fromBirthYear(cls, name, year):
        return cls(name, date.today().year - year)
     
    # a static method to check if a Person is adult or not.
    @staticmethod
    def isAdult(age):
        return age > 18
 
person1 = Person('mayank', 21)
person2 = Person.fromBirthYear('mayank', 1996)
 
print(person1.age)
print(person2.age)
 
# print the result
print(Person.isAdult(22))
```


## 4.4. Strings:
>* Creating Strings:

```python
name = "tom" # a string
mychar = 'a' # a character

name1 = str() # this will create empty string object
name2 = str("newstring") # string object containing 'newstring'
```

>* Strings in python are immutable: (**once string is created it can’t be modified**)

```python
str1 = "welcome"
str2 = "welcome"
id(str1) == id(str2) #immutability can be tested by id function
```

>* Operations on string:
>>* Getting characters using index (index starts with 0)

```python
name='Amandeep'
name[0] #
```

>>* '+' & '*' operator for concatenation

```python
print("tom and " + "jerry")

print('Amandeep'*2)
```


>>* [] (slicing) operator: used for subsetting the string [s[start:end]]

```python
s = "Welcome"
print(s[1:3])
print(s[1 : -1])
print(s[4 : ])
```

>>* in  and not in  operators (used to check existence)

```python
s1 = "Welcome"
"come" in s1
#True

"come" not in s1
#False
```

>>* String comparision
>>>* You can use ( > , < , <= , <= , == , !=  ) to compare two strings.
>>>* Python compares string lexicographically i.e using ASCII value of the characters.
>>>* It starts with integers and then to characters like "1" < "a" returns true. (same with --> "1999" < "a")

```python
"tim" == "tie"
#False
"free" != "freedom"
#True
"arrow" > "aron"
#True
"right" >= "left"
#True
"teeth" < "tee"
#False
"yellow" <= "fellow"
#False
"abc" > ""
#True
```


>* Getting characters using index (index starts with 0)
>>>* **ord()** – function returns the ASCII code of the character.
>>>* **chr()** – function returns character represented by a ASCII number.

```python
ch = 'b'
ord(ch)
#98

chr(97)
#'a'

ord('A')
#65
```

>* String Functions in python

|FUNCTION   |NAME	|FUNCTION DESCRIPTION|
|---|---|---|
|len()	    |returns |length of the string|
|max()	    |returns |character having highest ASCII value|
|min()	    |returns |character having lowest ASCII value|

```python
len("hello")
#5
max("abc")
#'c'
min("abc")
#'a'
```

>* Iterating string using for loop
>>* **By default print()  function prints string with a newline , we change this behavior by supplying a second argument to it as follows.** 

```python
s = "hello"
for i in s:
    print(i, end="")
#hello

print("my string", end="\n")  #this is default behavior

print("my string", end="")    # print string without a newline

print("my string", end="foo")  # now print() will print foo after every string
```

>* Testing strings

|METHOD NAME	    |METHOD DESCRIPTION|
|---|---|
|isalnum()	    |Returns True if string is alphanumeric|
|isalpha()	    |Returns True if string contains only alphabets|
|isdigit()	    |Returns True if string contains only digits|
|isidentifier()	|Return True is string is valid identifier|
|islower()	    |Returns True if string is in lowercase|
|isupper()	    |Returns True if string is in uppercase|
|isspace()	    |Returns True if string contains only whitespace|


```python
s = "welcome to python"

s.isalnum()
#False

"Welcome".isalpha()
#True

"2012".isdigit()
#True

"first Number".isidentifier()
#False

"1_a".isidentifier()
"_a".isidentifier()

s.islower()
#True

"WELCOME".isupper()
#True

"  \t".isspace()
#True
```
 
>* Searching for Substrings

|METHOD NAME	                    |METHODS DESCRIPTION:|
|---|---|
|str.endswith(s1): bool	            |Returns True if strings ends with substring s1|
|str.startswith(s1): bool	        |Returns True if strings starts with substring s1|
|str.count(substring): int	        |Returns number of occurrences of substring the string|
|str.find(s1): int	                |Returns **lowest index** from where s1 starts in the string, if string not found returns -1|
|str.index(s1): int	                |Same as find method, it's just that it will throw error in place of returning -1 if substring not found|
|rfind(s1): int	                    |Returns **highest index** from where s1 starts in the string, if string not found returns -1|
|str.rindex(s1): int	            |Same as rfind method, it's just that it will throw error in place of returning -1 if substring not found|

```python
s = "welcome to python"

s.endswith("thon")
#True

s.startswith("good")
#False

s.find("come")
#3

s.find("become")
#-1

s.rfind("o")
#15

s.count("o")
#3

```

>* Converting Strings

|METHOD NAME	            |METHOD DESCRIPTION|
|---|---|
|capitalize(): str	            |Returns a copy of this string with only the first character capitalized.|
|lower(): str	                |Return string by converting every character to lowercase|
|upper(): str	                |Return string by converting every character to uppercase|
|title(): str	                |This function return string by capitalizing first letter of every word in the string|
|swapcase(): str	            |Return a string in which the lowercase letter is converted to uppercase and uppercase to lowercase|
|replace(old, new): str	        |This function returns new string by replacing the occurrence of old string with new string|
|s.center(<width>[, <fill>])	|'foo'.center(10) returns '   foo    ' && 'bar'.center(10, '-') returns '---bar----'|
|s.ljust(<width>[, <fill>])    |'foo'.ljust(10) returns 'foo       ' && 'foo'.ljust(10, '-') returns 'foo-------'|
|s.lstrip([<chars>])           |Trims leading characters from a string|
|s.zfill(<width>)              |'42'.zfill(5) returns '00042'|
|s.partition(<sep>)            |s.partition(<sep>) splits s at the first occurrence of string <sep>. The return value is a three-part tuple consisting of:<br>The portion of s preceding <sep><br><sep> itself<br>The portion of s following <sep><br>|

```python

'   foo bar baz   '.lstrip()
#'foo bar baz   '
'\t\nfoo\t\nbar\t\nbaz'.lstrip()
#'foo\t\nbar\t\nbaz'

# If the optional <chars> argument is specified, it is a string that specifies the set of characters to be removed:
'http://www.realpython.com'.lstrip('/:pth') # 
# 'www.realpython.com'

# If s contains a leading sign, it remains at the left edge of the result string after zeros are inserted:
'+42'.zfill(8)
# '+0000042'
'-42'.zfill(8)
# '-0000042'

s = "string in python"

s1 = s.capitalize()
s1

s = 'foO BaR BAZ quX'
s.capitalize() # Non-alphabetic characters are unchanged
# 'Foo bar baz qux'

#'String in python'

s2 = s.title()
s2
#'String In Python'

s = "This Is Test"
s3 = s.lower()
s3
#'this is test'

s4 = s.upper()
s4
#'THIS IS TEST'

s5 = s.swapcase()
s5
#'tHIS iS tEST'

s6 = s.replace("Is", "Was")
s6
#'This Was Test'

```


>* 
>* 

## 4.5. Different Literals:
>* A literal is something that the parser recognizes as syntax for writing an object directly
>>* -3, -2, -1, 0, 1, 2, 3 (int literals)
>>* 2+3j, 0+5j, 2j, -3-5j (complex literals)
>>* 3.5, -2.7 (float literals)
>>* "", "hello" (str literals)
>>* u"", u"hello" (unicode literals)
>>* [], [1,2] (list literals)
>>* (), (1,), (1,2) (tuple literals)
>>* {}, {'a': 2} (dict literals)
>>* {1,2,3} (set literal)
>>* None ( literal or keyword )

## 4.6. Math Operators and Expressions: [Inbuilt Operators in python](https://www.geeksforgeeks.org/basic-operators-python/)
>* The math module is a standard module in Python and is always available. 
>* To use mathematical functions under this module, you have to import the module using import math. 

|Function	        |Description|
|---|---|
|ceil(x)	        |Returns the smallest integer greater than or equal to x.|
|copysign(x, y)	    |Returns x with the sign of y|
|fabs(x)	        |Returns the absolute value of x (will always return float unlike abs whose output type depends upon input type)|
|factorial(x)	    |Returns the factorial of x|
|floor(x)	        |Returns the largest integer less than or equal to x|
|fmod(x, y)	        |Returns the remainder when x is divided by y <BR> (Note that the Python expression x % y may not return the same result)  <BR> eg - fmod(-1e-100, 1e100),   -1e-100 % 1e100.  <BR> function fmod() is generally **preferred** when working with floats,  <BR> while Python’s x % y is **preferred** when working with integers.|
|frexp(x)	        |Returns the mantissa and exponent of x as the pair (m, e), x == m * 2**e|
|fsum(iterable)	    |Returns an accurate floating point sum of values in the iterable|
|isfinite(x)	    |Returns True if x is neither an infinity nor a NaN (Not a Number) - math.nan or math.inf|
|isinf(x)	        |Returns True if x is a positive or negative infinity|
|isnan(x)	        |Returns True if x is a NaN|
|ldexp(x, i)	    |Returns x * (2**i) - ldexp(frexp(x)) == x -->true always|
|modf(x)	        |Returns the fractional and integer parts of x, math.modf(9.5) ==> (0.5, 9.0)|
|trunc(x)	        |Returns the truncated integer value of x - used to remove the decimal values from specified expression and return the integer value.|
|exp(x)	            |Returns e**x|
|expm1(x)	        |Returns e**x - 1|
|log(x[, base])	    |Returns the logarithm of x to the base (defaults to e)|
|log1p(x)	        |Returns the natural logarithm of 1+x|
|log2(x)	        |Returns the base-2 logarithm of x|
|log10(x)	        |Returns the base-10 logarithm of x|
|pow(x, y)	        |Returns x raised to the power y|
|sqrt(x)	        |Returns the square root of x|
|acos(x)	        |Returns the arc/inverse cosine of x|
|asin(x)	        |Returns the arc sine of x|
|atan(x)	        |Returns the arc tangent of x|
|atan2(y, x)	    |Returns atan(y / x)|
|cos(x)	            |Returns the cosine of x|
|hypot(x, y)	    |Returns the Euclidean norm, sqrt(x*x + y*y) - math.hypot(3,4) -> 5 |
|sin(x)	            |Returns the sine of x|
|tan(x)	            |Returns the tangent of x|
|degrees(x)	        |Converts angle x from radians to degrees - math.degrees(math.pi) -> 180|
|radians(x)	        |Converts angle x from degrees to radians|
|acosh(x)	        |Returns the inverse hyperbolic cosine of x|
|asinh(x)	        |Returns the inverse hyperbolic sine of x|
|atanh(x)	        |Returns the inverse hyperbolic tangent of x|
|cosh(x)	        |Returns the hyperbolic cosine of x|
|sinh(x)	        |Returns the hyperbolic cosine of x|
|tanh(x)	        |Returns the hyperbolic tangent of x|
|erf(x)	            |Returns the error function at x - PENDING|
|erfc(x)	        |Returns the complementary error function at x - PENDING|
|gamma(x)	        |Returns the Gamma function at x - PENDING|
|lgamma(x)	        |Returns the natural logarithm of the absolute value of the Gamma function at x - PENDING|
|pi	                |Mathematical constant, the ratio of circumference of a circle to it's diameter (3.14159...)|
|e	                |mathematical constant e (2.71828...)|


```python
import math
num = 100
m,e = math.frexp(num)
m* 2**e
```

## 4.7. Writing to the Screen:

```python
print('Hello World')
```

## 4.8. String Formatting:
>* Python uses C-style string formatting to create new, formatted strings. 
>>* The "%" operator is used to format a set of variables enclosed in a "tuple" (a fixed size list), together with a format string, which contains normal text together with "argument specifiers", special symbols like:
>>>* %s - String (or any object with a string representation, like numbers)
>>>* %d - Integers
>>>* %f - Floating point numbers
>>>* %.<number of digits>f - Floating point numbers with a fixed amount of digits to the right of the dot.
>>>* %x/%X - Integers in hex representation (lowercase/uppercase)

>* To use two or more argument specifiers, use a tuple (parentheses)
>* Any object which is not a string can be formatted using the %s operator as well. The string which returns from the "repr" method of that object is formatted as the string.
>* To reverse a string simply give step as -1

>* **Examples**

```python
# This prints out "Hello, Aman!"
name = "Aman"
print("Hello, %s!" % name)


# This prints out "Aman is 27 years old."
name = "Aman"
age = 27
print("%s is %d years old." % (name, age))


# This prints out: A list: [1, 2, 3]
mylist = [1,2,3]
print("A list: %s" % mylist)


name = "Aman"
age = 27.99
print("%s is %.1f years old." % (name, age))
#Aman is 28.0 years old.

my_string = "Hello world!"
print(my_string[3:7:2])


my_string = "Hello world!"
print(my_string[::-1])


"".join(list(reversed('India is great')))


my_string = "Hello world!"
words_list = my_string.split(" ")
print(words_list)

```

>* **Interpolating Variables Into a String**: There is concept of f-strings where we can directly use variable names inside the quotes:
```python
n = 20
m = 25
prod = n * m
print(f'The product of {n} and {m} is {prod}')
```

## 4.9. Command Line Parameters and Flow Control:
>* sys.argv is the list of commandline arguments passed to the Python program. 
>* argv represents all the items that come along via the commandline input in a list
>* first argument (at index 0) will always be the python file which we ran

```python
import sys

print(type(sys.argv))
print(sys.argv)
```